// Generated by CoffeeScript 1.7.1

/*
Module dependencies.
 */

(function() {
  var Entry, Feed, Memcached, app, cron, express, http, memClient, path, request;

  express = require("express");

  http = require("http");

  path = require("path");

  request = require("request");

  cron = require("cron");

  Memcached = require("./memcached-wrapper");

  Feed = require("./models/feed");

  Entry = require("./models/entry");

  memClient = new Memcached("localhost", 11211);

  app = express();

  app.set("port", process.env.PORT || 3000);

  app.set("views", path.join(__dirname, "views"));

  app.set("view engine", "ejs");

  app.use(express.favicon());

  app.use(express.logger("dev"));

  app.use(express.json());

  app.use(express.urlencoded());

  app.use(express.methodOverride());

  app.use(app.router);

  app.get("/rss", function(req, res) {
    return memClient.get(function(e, r) {
      console.log("result = " + (JSON.stringify(r)));
      return res.render("rss", r);
    });
  });

  http.createServer(app).listen(app.get("port"), function() {
    console.log("Express server listening on port " + app.get("port"));
  });

  console.log("Token: " + process.env.TOKEN);

  new cron.CronJob({
    cronTime: "* */30 * * * *",
    onTick: function() {
      request.get({
        url: "https://qiita.com/api/following?after=0&token=" + process.env.TOKEN,
        json: true
      }, function(e, r, json) {
        var feed, newEntries;
        if (r.statusCode !== 200) {
          return console.log("error: " + r.statusCode);
        }
        feed = new Feed(process.env.USER_NAME);
        newEntries = [];
        memClient.get(function(error, result) {
          if (!result) {
            json.forEach(function(elem) {
              return feed.addEntry(new Entry(elem));
            });
            memClient.set(feed);
            return;
          }
          json.forEach(function(elem) {
            if (result.entries[0].updated_at >= elem.target_content.updated_at) {
              return;
            }
            return newEntries.push(new Entry(elem));
          });
          newEntries.concat(result);
          feed.setEntries(newEntries);
          return memClient.set(feed);
        });
      });
    },
    start: false,
    timeZone: "Japan/Tokyo"
  }).start();

}).call(this);
